Name

    OES_framebuffer_object

Name Strings

    GL_OES_framebuffer_object

Contact

    Aaftab Munshi (amunshi@ati.com)

IP Status

    None.

Status

    Ratified by the Khronos BOP, July 22, 2005.

Version

    Last Modified Date: April 22, 2007

Number

    OpenGL ES Extension #10

Dependencies

    OpenGL ES 1.0 is required.

Overview

    This extension defines a simple interface for drawing to rendering
    destinations other than the buffers provided to the GL by the
    window-system.  OES_framebuffer_object is a simplified version
    of EXT_framebuffer_object with modifications to match the needs of 
    OpenGL ES.

    In this extension, these newly defined rendering destinations are
    known collectively as "framebuffer-attachable images".  This
    extension provides a mechanism for attaching framebuffer-attachable
    images to the GL framebuffer as one of the standard GL logical
    buffers: color, depth, and stencil.  When a framebuffer-attachable 
    image is attached to the framebuffer, it is used as the source and
    destination of fragment operations as described in Chapter 4.

    By allowing the use of a framebuffer-attachable image as a rendering
    destination, this extension enables a form of "offscreen" rendering.
    Furthermore, "render to texture" is supported by allowing the images
    of a texture to be used as framebuffer-attachable images.  A
    particular image of a texture object is selected for use as a
    framebuffer-attachable image by specifying the mipmap level, cube
    map face (for a cube map texture) that identifies the image.  
    The "render to texture" semantics of this extension are similar to 
    performing traditional rendering to the framebuffer, followed 
    immediately by a call to CopyTexSubImage.  However, by using this 
    extension instead, an application can achieve the same effect, 
    but with the advantage that the GL can usually eliminate the data copy 
    that would have been incurred by calling CopyTexSubImage.

    This extension also defines a new GL object type, called a
    "renderbuffer", which encapsulates a single 2D pixel image.  The
    image of renderbuffer can be used as a framebuffer-attachable image
    for generalized offscreen rendering and it also provides a means to
    support rendering to GL logical buffer types which have no
    corresponding texture format (stencil, etc).  A renderbuffer
    is similar to a texture in that both renderbuffers and textures can
    be independently allocated and shared among multiple contexts.  The
    framework defined by this extension is general enough that support
    for attaching images from GL objects other than textures and
    renderbuffers could be added by layered extensions.

    To facilitate efficient switching between collections of
    framebuffer-attachable images, this extension introduces another new
    GL object, called a framebuffer object.  A framebuffer object
    contains the state that defines the traditional GL framebuffer,
    including its set of images.  Prior to this extension, it was the
    window-system which defined and managed this collection of images,
    traditionally by grouping them into a "drawable".  The window-system
    APIs would also provide a function (i.e., eglMakeCurrent) to bind a 
    drawable with a GL context.  In this extension, however, this 
    functionality is subsumed by the GL and the GL provides the function 
    BindFramebufferOES to bind a framebuffer object to the current context.  
    Later, the context can bind back to the window-system-provided framebuffer 
    in order to display rendered content.

    Previous extensions that enabled rendering to a texture have been
    much more complicated.  One example is the combination of
    ARB_pbuffer and ARB_render_texture, both of which are window-system
    extensions.  This combination requires calling MakeCurrent, an
    operation that may be expensive, to switch between the window and
    the pbuffer drawables.  An application must create one pbuffer per
    renderable texture in order to portably use ARB_render_texture.  An
    application must maintain at least one GL context per texture
    format, because each context can only operate on a single
    pixelformat or FBConfig.  All of these characteristics make
    ARB_render_texture both inefficient and cumbersome to use.

    OES_framebuffer_object, on the other hand, is both simpler to use
    and more efficient than ARB_render_texture.  The
    OES_framebuffer_object API is contained wholly within the GL API and
    has no (non-portable) window-system components.  Under
    OES_framebuffer_object, it is not necessary to create a second GL
    context when rendering to a texture image whose format differs from
    that of the window.  Finally, unlike the pbuffers of
    ARB_render_texture, a single framebuffer object can facilitate
    rendering to an unlimited number of texture objects.

    Please refer to the EXT_framebuffer_object extension for a 
    detailed explaination of how framebuffer objects are supposed to work,
    the issues and their resolution.  This extension can be found at
    http://oss.sgi.com/projects/ogl-sample/registry/EXT/framebuffer_object.txt

New Procedures and Functions

    boolean IsRenderbufferOES(uint renderbuffer);
    void BindRenderbufferOES(enum target, uint renderbuffer);
    void DeleteRenderbuffersOES(sizei n, const uint *renderbuffers);
    void GenRenderbuffersOES(sizei n, uint *renderbuffers);

    void RenderbufferStorageOES(enum target, enum internalformat,
                                sizei width, sizei height);

    void GetRenderbufferParameterivOES(enum target, enum pname, int* params);

    boolean IsFramebufferOES(uint framebuffer);
    void BindFramebufferOES(enum target, uint framebuffer);
    void DeleteFramebuffersOES(sizei n, const uint *framebuffers);
    void GenFramebuffersOES(sizei n, uint *framebuffers);

    enum CheckFramebufferStatusOES(enum target);

    void FramebufferTexture2DOES(enum target, enum attachment,
                                 enum textarget, uint texture,
                                 int level);

    void FramebufferRenderbufferOES(enum target, enum attachment,
                                    enum renderbuffertarget, uint renderbuffer);

    void GetFramebufferAttachmentParameterivOES(enum target, enum attachment,
                                                enum pname, int *params);

    void GenerateMipmapOES(enum target);

New Tokens

    Accepted by the <target> parameter of BindFramebufferOES,
    CheckFramebufferStatusOES, FramebufferTexture{2D|3D}OES,
    FramebufferRenderbufferOES, and
    GetFramebufferAttachmentParameterivOES:

        FRAMEBUFFER_OES                     0x8D40

    Accepted by the <target> parameter of BindRenderbufferOES,
    RenderbufferStorageOES, and GetRenderbufferParameterivOES, and
    returned by GetFramebufferAttachmentParameterivOES:

        RENDERBUFFER_OES                    0x8D41

    Accepted by the <internalformat> parameter of
    RenderbufferStorageOES:

        RGB565_OES                          0x8D62
        STENCIL_INDEX1_OES                  0x8D46
        STENCIL_INDEX4_OES                  0x8D47
        STENCIL_INDEX8_OES                  0x8D48

    Accepted by the <pname> parameter of GetRenderbufferParameterivOES:

        RENDERBUFFER_WIDTH_OES              0x8D42
        RENDERBUFFER_HEIGHT_OES             0x8D43
        RENDERBUFFER_INTERNAL_FORMAT_OES    0x8D44
        RENDERBUFFER_RED_SIZE_OES           0x8D50
        RENDERBUFFER_GREEN_SIZE_OES         0x8D51
        RENDERBUFFER_BLUE_SIZE_OES          0x8D52
        RENDERBUFFER_ALPHA_SIZE_OES         0x8D53
        RENDERBUFFER_DEPTH_SIZE_OES         0x8D54
        RENDERBUFFER_STENCIL_SIZE_OES       0x8D55

    Accepted by the <pname> parameter of
    GetFramebufferAttachmentParameterivOES:

        FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE_OES            0x8CD0
        FRAMEBUFFER_ATTACHMENT_OBJECT_NAME_OES            0x8CD1
        FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL_OES          0x8CD2
        FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE_OES  0x8CD3
        FRAMEBUFFER_ATTACHMENT_TEXTURE_3D_ZOFFSET_OES     0x8CD4

    Accepted by the <attachment> parameter of
    FramebufferTexture{2D|3D}OES, FramebufferRenderbufferOES, and
    GetFramebufferAttachmentParameterivOES

        COLOR_ATTACHMENT0_OES                0x8CE0
        COLOR_ATTACHMENT1_OES                0x8CE1
        COLOR_ATTACHMENT2_OES                0x8CE2
        COLOR_ATTACHMENT3_OES                0x8CE3
        COLOR_ATTACHMENT4_OES                0x8CE4
        COLOR_ATTACHMENT5_OES                0x8CE5
        COLOR_ATTACHMENT6_OES                0x8CE6
        COLOR_ATTACHMENT7_OES                0x8CE7
        COLOR_ATTACHMENT8_OES                0x8CE8
        COLOR_ATTACHMENT9_OES                0x8CE9
        COLOR_ATTACHMENT10_OES               0x8CEA
        COLOR_ATTACHMENT11_OES               0x8CEB
        COLOR_ATTACHMENT12_OES               0x8CEC
        COLOR_ATTACHMENT13_OES               0x8CED
        COLOR_ATTACHMENT14_OES               0x8CEE
        COLOR_ATTACHMENT15_OES               0x8CEF
        DEPTH_ATTACHMENT_OES                 0x8D00
        STENCIL_ATTACHMENT_OES               0x8D20

    Returned by CheckFramebufferStatusOES():

        FRAMEBUFFER_COMPLETE_OES                          0x8CD5
        FRAMEBUFFER_INCOMPLETE_ATTACHMENT_OES             0x8CD6
        FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT_OES     0x8CD7
        FRAMEBUFFER_INCOMPLETE_DIMENSIONS_OES             0x8CD9
        FRAMEBUFFER_INCOMPLETE_FORMATS_OES                0x8CDA
        FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER_OES            0x8CDB
        FRAMEBUFFER_INCOMPLETE_READ_BUFFER_OES            0x8CDC
        FRAMEBUFFER_UNSUPPORTED_OES                       0x8CDD

    Accepted by GetIntegerv():

        FRAMEBUFFER_BINDING_OES             0x8CA6
        RENDERBUFFER_BINDING_OES            0x8CA7
        MAX_COLOR_ATTACHMENTS_OES           0x8CDF
        MAX_RENDERBUFFER_SIZE_OES           0x84E8

    Returned by GetError():

        INVALID_FRAMEBUFFER_OPERATION_OES   0x0506

OES_framebuffer_object implements the functionality defined by EXT_framebuffer_object 
with the following limitations:

    - there is no support for DrawBuffer{s}, ReadBuffer{s}.

    - FramebufferTexture2DOES can be used to render 
      directly into the base level of a texture image only.  Rendering to any 
      mip-level other than the base level is not supported.

    - FramebufferTexture3DOES is optionally supported and is implemented only
      if OES_texture_3D string is defined in the EXTENSIONS string returned by 
      OpenGL ES.

    - section 4.4.2.1 of the EXT_framebuffer_object spec describes the function
      RenderbufferStorageEXT.  This function establishes the data storage, format, 
      and dimensions of a renderbuffer object's image.  <target> must be 
      RENDERBUFFER_EXT. <internalformat> must be one of the internal formats 
      from table 3.16 or table 2.nnn which has a base internal format of RGB, RGBA, 
      DEPTH_COMPONENT, or STENCIL_INDEX.

      The above paragraph is modified by OES_framebuffer_object and states thus:

      "This function establishes the data storage, format, and 
      dimensions of a renderbuffer object's image.  <target> must be RENDERBUFFER_OES.
      <internalformat> must be one of the sized internal formats from the following 
      table which has a base internal format of RGB, RGBA, DEPTH_COMPONENT, 
      or STENCIL_INDEX"

       The following formats are required:

                Sized                 Base                  
                Internal Format       Internal format      
                ---------------       ---------------       
                RGB565_OES            RGB                
                RGBA4                 RGBA               
                RGB5_A1               RGBA               
                DEPTH_COMPONENT_16    DEPTH_COMPONENT    

        The following formats are optional:

                Sized                 Base                  
                Internal Format       Internal format      
                ---------------       ---------------       
                RGBA8                 RGBA                    
                RGB8                  RGB                
                DEPTH_COMPONENT24     DEPTH_COMPONENT    
                DEPTH_COMPONENT32     DEPTH_COMPONENT    
                STENCIL_INDEX1_OES    STENCIL_INDEX      
                STENCIL_INDEX4_OES    STENCIL_INDEX      
                STENCIL_INDEX8_OES    STENCIL_INDEX      

       
       The optional formats are described by the OES_rgb8_rgba8, OES_depth24,
       OES_depth32, OES_stencil1, OES_stencil4, and OES_stencil8 extensions.
       Even though these formats are optional in this extension, the OpenGL ES
       APIs (1.x and 2.x versions) can mandate some or all of these optional formats.
       
       If RenderbufferStorageOES is called with an <internalformat> value that is 
       not supported by the OpenGL ES implementation, an INVALID_ENUM error will 
       be generated.

Revision History

    02/25/2005   Aaftab Munshi    First draft of extension
    04/27/2005   Aaftab Munshi    Added additional limitations to simplify
                                  OES_framebuffer_object implementations
    07/06/2005   Aaftab Munshi    Added GetRenderbufferStorageFormatsOES
                                  removed limitations that were added to OES
                                  version of RenderbufferStorage,
                                  and FramebufferTexture2DOES.
    07/07/2005   Aaftab Munshi    Removed GetRenderbufferStorageFormatsOES
                                  after discussions with Jeremy Sandmel,
                                  and added specific extensions for the
                                  optional renderbuffer storage foramts
    07/18/2005   Aaftab Munshi    Added comment that optional formats can
                                  be mandated by OpenGL ES APIs.
    06/03/2006   Aaftab Munshi    Sync to revision 118 of EXT_framebuffer_object
    04/22/2007   Jon Leech        Restore RGB565_OES to "New Tokens" section.

